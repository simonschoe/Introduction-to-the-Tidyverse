<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Machine Learning in R: Workshop Series</title>
    <meta charset="utf-8" />
    <meta name="author" content="Simon SchÃ¶lzel" />
    <link rel="stylesheet" href="custom/xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="custom/custom-theme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: left, middle, inverse, title-slide

# Machine Learning in R:<br/>Workshop Series
## Introduction to the<br>Tidyverse
### Simon SchÃ¶lzel
### <em>Research Team Berens</em>
### 2020-11-09 (updated: 2020-11-08)

---








name: agenda

## Agenda

**1 Learning Objectives**

**2 Introduction to the `tidyverse`**  
&gt; 2.1 What is the `tidyverse`  
2.2 The Concept of Tidy Data
  
**3 `palmerpenguins`: Palmer Archipelago (Antarctica) Penguin Data**

**4 The Core `tidyverse` Packages**  
&gt; 4.1 `magrittr`: A Forward-Pipe Operator for `R`  
4.2 `tibble`: Simple Data Frames  
4.3 `readr`: Read Rectangular Text Data  
4.4 `tidyr`: Tidy Messy Data  
4.5 `dplyr`: A Grammar of Data Manipulation  
4.6 `purrr`: Functional Programming Tools  
4.7 `ggplot2`: Create Elegant Data Visualisations Using the Grammar of Graphics

???
comment

---

## 1 Learning Objectives ðŸ’¡

This workshop teaches you important tools for working with rectangular data sets in `R`. It introduces and showcases a suite of packages which eases your data science workflow in terms of data import, data cleaning, data transformation and data visualization.

More specifically, after this workshop you will
- be familiar with the main tools of the `tidyverse` and how it differs from `base R`,&lt;br&gt;&lt;br&gt;
- know your way around in working with the core packages of the `tidyverse` for importing, tidying, transforming and visualizing data,&lt;br&gt;&lt;br&gt;
- be proficient in processing (*non-tidy*) data of any shape and quality,&lt;br&gt;&lt;br&gt;
- be able to produce high-quality, fully customizable visualizations,&lt;br&gt;&lt;br&gt;
- have improved your overall data literacy.

???
especially highlight the last point: how you think about data, how you approach working with data whenever you open a new data set, build a mental model for data transformation operations

---



---



---



---



---



---



---



class: middle, center, inverse
layout: false

# 4.5 `dplyr`:&lt;br&gt;&lt;br&gt;A Grammar of Data Manipulation

---

background-image: url(https://raw.githubusercontent.com/tidyverse/dplyr/master/man/figures/logo.png)
background-position: 95% 5%
background-size: 7.5%
layout: true

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

`dplyr` provides a set of functions for manipulating data frame objects (e.g., `tibbles`) while relying on a consistent grammar. Functions are intuitively represented by "verbs" that reflect the underlying operations and always output a new or modified `tibbles`.

**Operations on rows:**
- `filter()` picks rows that meet one or several logical criteria
- `slice()` picks rows based on their location in the data
- `arrange()` changes the order of rows

**Operations on columns:**
- `select()` picks respectively drops certain columns
- `rename()` changes the column names
- `relocate()` changes the order of columns
- `mutate()` transforms the column values and/or creates new columns

**Operations on grouped data:**
- `group_by()` partitions data based on one or several columns
- `summarise()` reduces a group of data into a single row

???
comment

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on rows:** `filter()` picks rows that meet one or several logical criteria

.pull-left[
Filter for all penguins of `species` "Adelie":

```r
penguins %&gt;% 
  filter(species == "Adelie")
```

Filter for all penguins where the is a missing value in the `bill_length_mm` measurement:

```r
penguins %&gt;% 
  filter(is.na(bill_length_mm) == T)
  # filter(!is.na(bill_length_mm) == F)
```
]
.pull-right[
&lt;img src="https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork/dplyr_filter.jpg" width="90%" height="90%" style="display: block; margin: auto;" /&gt;
]

Filter for all penguins observed prior to `year` 2008 or subsequent to `year` 2008 and where the body mass (`body_mass_g`) lies between 3,800 and 4,000 grams:

```r
penguins %&gt;% 
  filter(between(body_mass_g, 3800, 4000) &amp; (year &lt; 2008 | year &gt; 2008))
```

???
 - Note that using `=` instead of `==` is a common mistakes for beginners (`&lt;-` = `=`).

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on rows:** `slice()` picks rows based on their location in the data


```r
penguins %&gt;% 
  slice(23:26)
```

```
&gt; # A tibble: 4 x 8
&gt;   species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;
&gt; 1 Adelie  Biscoe           35.9          19.2              189        3800 fema~
&gt; 2 Adelie  Biscoe           38.2          18.1              185        3950 male 
&gt; 3 Adelie  Biscoe           38.8          17.2              180        3800 male 
&gt; 4 Adelie  Biscoe           35.3          18.9              187        3800 fema~
&gt; # ... with 1 more variable: year &lt;dbl&gt;
```
**Other `slice_*()` functions:**
- `slice_head()` (`slice_tail()`) lets you pick the `n` first (last) observations in the data frame.
- `slice_sample()` lets you pick a random sample of `n` observations (with or without replacement).
- `slice_min()` (`slice_max()`) lets you pick the `n` largest (smallest) observations in the data frame.

???
- slice_sample to generate bootstrapped samples

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on rows:** `arrange()` changes the order of rows

Return the three penguins with the smallest body mass: 

```r
penguins %&gt;% 
  arrange(body_mass_g) %&gt;% 
  slice_head(n = 3)  # equivalent to using slice_min(order_by = body_mass_g, n = 3)
```

```
&gt; # A tibble: 3 x 8
&gt;   species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;
&gt; 1 Chinst~ Dream            46.9          16.6              192        2700 fema~
&gt; 2 Adelie  Biscoe           36.5          16.6              181        2850 fema~
&gt; 3 Adelie  Biscoe           36.4          17.1              184        2850 fema~
&gt; # ... with 1 more variable: year &lt;dbl&gt;
```

Return the three penguins with the highest body mass: 

```r
penguins %&gt;% 
  arrange(desc(body_mass_g)) %&gt;% 
  slice_head(n = 3)  # equivalent to using slice_max(order_by = body_mass_g, n = 3)
```

???
- arrange by default always sorts from smallest to largest

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on columns:** `select()` picks respectively drops certain columns

.pull-left[
Select the first three columns (by index):

```r
penguins %&gt;% 
  select(1:3)
```
]
.pull-right[
Select the first three columns (by name):

```r
penguins %&gt;% 
  select(species, island, bill_length_mm)
```
]

-- 

**Frequently used helper functions:**
- `everything()`: select all columns
- `last_col()`: select the last column in the data frame
- `starts_with()`: select columns which names start with a certain string
- `ends_with()`: select columns which names end with a certain string
- `contains()`: select columns which name contains a certain string  
- `where()`: select columns for which a function evaluates to `TRUE`

???
comment

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on columns:** `select()` picks respectively drops certain columns

Which columns are returned by the following queries? Try it out at home :)
.pull-left[

```r
penguins %&gt;% 
  select(starts_with("s"))
```


```r
penguins %&gt;% 
  select(ends_with("mm"))
```
]
.pull-right[

```r
penguins %&gt;% 
  select(contains("mm"))
```


```r
penguins %&gt;% 
  select(-contains("mm"))
```
]

```r
penguins %&gt;% 
  select(where(is.numeric)) %&gt;%   # equivalent to select(where(~is.numeric(.)))
  select(where(~ mean(., na.rm = T) &gt; 1000))
```

???
- feed a function that takes a vector and returns T or F
- if you want to deselect something put a minus in front
- when using a function within another function you usually require the formula (~) notation (see `purrr` part), except when only using a function with one argument

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on columns:** `rename()` changes the column names

Change the name of the column `body_mass_g` (`sex`) to `bm` (`gender`):

```r
penguins %&gt;% 
  rename(bm = body_mass_g, gender = sex) %&gt;% 
  colnames()
```

```
&gt; [1] "species"           "island"            "bill_length_mm"   
&gt; [4] "bill_depth_mm"     "flipper_length_mm" "bm"               
&gt; [7] "gender"            "year"
```
Convert the name of the columns that include the string "mm" to upper case:

```r
penguins %&gt;% 
  rename_with(.fn = toupper, .cols = contains("mm")) %&gt;% 
  colnames()
```

```
&gt; [1] "species"           "island"            "BILL_LENGTH_MM"   
&gt; [4] "BILL_DEPTH_MM"     "FLIPPER_LENGTH_MM" "body_mass_g"      
&gt; [7] "sex"               "year"
```

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on columns:** `relocate()` changes the order of columns

.pull-left[
Change the order of columns in the `tibble` according to the following scheme:
1. place `species` after `body_mass_g`
2. place `sex` before `species`
3. place `island` at the end


```r
penguins %&gt;% 
  relocate(species, .after = body_mass_g) %&gt;%
  relocate(sex, .before = species) %&gt;%
  relocate(island, .after = last_col()) %&gt;%
  colnames()
```

```
&gt; [1] "bill_length_mm"    "bill_depth_mm"     "flipper_length_mm"
&gt; [4] "body_mass_g"       "sex"               "species"          
&gt; [7] "year"              "island"
```
]
.pull-right[
&lt;img src="https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork/dplyr_relocate.png" width="70%" height="70%" style="display: block; margin: auto;" /&gt;
]

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on columns:** `mutate()` transforms the column values and/or creates new columns

.pull-left[
Engineer a new `bm_kg` variable which reflects `body_mass_g` measured in kilo grams:

```r
penguins %&gt;% 
  mutate(
    bm_kg = body_mass_g / 1000,
    .keep = "all",
    .after = body_mass_g) %&gt;% 
  slice_head(n = 3)
```
]
.pull-right[
- Use the `.keep` argument to specify which columns to keep after manipulation.
- Use the `.before`/`.after` arguments to specify the position of the new column.
- For overriding a given column simply use the same column name.
- For keeping only the new column use `dplyr::transmute()`.
]

```
&gt; # A tibble: 3 x 9
&gt;   species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g bm_kg
&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;
&gt; 1 Adelie  Torge~           39.1          18.7              181        3750  3.75
&gt; 2 Adelie  Torge~           39.5          17.4              186        3800  3.8 
&gt; 3 Adelie  Torge~           40.3          18                195        3250  3.25
&gt; # ... with 2 more variables: sex &lt;chr&gt;, year &lt;dbl&gt;
```


---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on columns:** `mutate()` transforms the column values and/or creates new columns

.pull-left[
Engineer a *one-hot encoded* dummy variable for `sex`:

```r
penguins %&gt;% 
  mutate(
    sex = case_when( # alternative: if_else()
      sex == "male" ~ 1,
      sex == "female" ~ 0),
    .keep = "all"
  ) %&gt;% 
  slice_head(n = 3)
```
]
.pull-right[
&lt;img src="https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork/dplyr_case_when.png" width="80%" height="80%" style="display: block; margin: auto;" /&gt;
]

```
&gt; # A tibble: 3 x 8
&gt;   species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g   sex
&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;
&gt; 1 Adelie  Torge~           39.1          18.7              181        3750     1
&gt; 2 Adelie  Torge~           39.5          17.4              186        3800     0
&gt; 3 Adelie  Torge~           40.3          18                195        3250     0
&gt; # ... with 1 more variable: year &lt;dbl&gt;
```

???
case_when:
- vectorized version of if_else
- two-sided formulas: LHS tests the condition, RHS specifies the replacement value
- for unmatched cases, the function returns NA
- use LHS True to capture all cases not explicitly specified beforehand

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on columns:** `mutate()` transforms the column values and/or creates new columns
.pull-left[
Transform measurement variables to meters:

```r
penguins %&gt;% 
  mutate(
    across(contains("mm"), ~ . / 1000),
    .keep = "all"
  ) %&gt;% 
  slice_head(n = 3)
```
]
.pull-right[
&lt;img src="https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork/dplyr_across.png" width="75%" height="75%" style="display: block; margin: auto;" /&gt;
]

```
&gt; # A tibble: 3 x 8
&gt;   species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;
&gt; 1 Adelie  Torge~         0.0391        0.0187            0.181        3750 male 
&gt; 2 Adelie  Torge~         0.0395        0.0174            0.186        3800 fema~
&gt; 3 Adelie  Torge~         0.0403        0.018             0.195        3250 fema~
&gt; # ... with 1 more variable: year &lt;dbl&gt;
```

???
across:
- apply same transformation across multiple columns
- allows you to use the semantics you know from the `select()` function
- does not require you to explicitly specify a column name as it only transform existing columns

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on columns:** `mutate()` transforms the column values and/or creates new columns

.pull-left[
Define `species`, `island` and `sex` as a categorical variables, i.e. *factors*:

```r
penguins %&gt;% 
  mutate(
    across(where(is.character), as.factor),
    .keep = "all"
  ) %&gt;% 
  slice_head(n = 3)
```
]
.pull-right[
&lt;img src="https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork/dplyr_across.png" width="75%" height="75%" style="display: block; margin: auto;" /&gt;
]

```
&gt; # A tibble: 3 x 8
&gt;   species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
&gt;   &lt;fct&gt;   &lt;fct&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;
&gt; 1 Adelie  Torge~           39.1          18.7              181        3750 male 
&gt; 2 Adelie  Torge~           39.5          17.4              186        3800 fema~
&gt; 3 Adelie  Torge~           40.3          18                195        3250 fema~
&gt; # ... with 1 more variable: year &lt;dbl&gt;
```

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on grouped data:** `group_by()` partitions data based on one or several columns

.pull-left[

```r
penguins %&gt;% 
  group_by(species) %&gt;% 
  slice_sample(n = 8)
```
]
.pull-right[
Use `group_keys()`, `group_indices()` and `group_vars()` to access grouping keys, group indices per row and grouping variables.
]

```
&gt; # A tibble: 24 x 8
&gt; # Groups:   species [3]
&gt;    species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
&gt;    &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;
&gt;  1 Adelie  Biscoe           40.5          17.9              187        3200 fema~
&gt;  2 Adelie  Dream            44.1          19.7              196        4400 male 
&gt;  3 Adelie  Biscoe           42            19.5              200        4050 male 
&gt;  4 Adelie  Torge~           37.7          19.8              198        3500 male 
&gt;  5 Adelie  Biscoe           36.5          16.6              181        2850 fema~
&gt;  6 Adelie  Dream            43.2          18.5              192        4100 male 
&gt;  7 Adelie  Torge~           36.6          17.8              185        3700 fema~
&gt;  8 Adelie  Torge~           42.1          19.1              195        4000 male 
&gt;  9 Chinst~ Dream            45.2          16.6              191        3250 fema~
&gt; 10 Chinst~ Dream            45.7          17.3              193        3600 fema~
&gt; # ... with 14 more rows, and 1 more variable: year &lt;dbl&gt;
```

???
comments

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on grouped data:** `group_by()` partitions data based on one or several columns

Under the hood `group_by()` changes the representation of the `tibble` and transforms it into a grouped data frame (`grouped_df`). This allows us to operate on the three subgroups individually using `summarise()`.

**Operations on grouped data:** `summarise()` reduces a group of data into a single row

.pull-left[

```r
penguins %&gt;% 
  group_by(species) %&gt;% # univariate
  summarise(count = n(), .groups = "drop")
```

```
&gt; # A tibble: 3 x 2
&gt;   species   count
&gt;   &lt;chr&gt;     &lt;int&gt;
&gt; 1 Adelie      152
&gt; 2 Chinstrap    68
&gt; 3 Gentoo      124
```
]
.pull-right[

```r
penguins %&gt;% 
  group_by(species, year) %&gt;% # bivariate
  summarise(count = n(), .groups = "drop")
```

```
&gt; # A tibble: 9 x 3
&gt;   species    year count
&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;int&gt;
&gt; 1 Adelie     2007    50
&gt; 2 Adelie     2008    50
&gt; 3 Adelie     2009    52
&gt; 4 Chinstrap  2007    26
&gt; 5 Chinstrap  2008    18
&gt; 6 Chinstrap  2009    24
&gt; 7 Gentoo     2007    34
&gt; 8 Gentoo     2008    46
&gt; 9 Gentoo     2009    44
```
]

???
- use ``.groups = ` to indicate what happens to the groups after summarising them

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on grouped data:** `group_by()` partitions data based on one or several columns and `summarise()` reduces a group of data into a single row


```r
penguins %&gt;% 
  group_by(species) %&gt;%
  summarise(
    across(contains("mm"), ~mean(., na.rm = T), .names = "{.col}_avg"),
    .groups = "drop"
  )
```

```
&gt; # A tibble: 3 x 4
&gt;   species   bill_length_mm_avg bill_depth_mm_avg flipper_length_mm_avg
&gt;   &lt;chr&gt;                  &lt;dbl&gt;             &lt;dbl&gt;                 &lt;dbl&gt;
&gt; 1 Adelie                  38.8              18.3                  190.
&gt; 2 Chinstrap               48.8              18.4                  196.
&gt; 3 Gentoo                  47.5              15.0                  217.
```

Using `group_by()`, followed by `summarise()` and `ungroup()` reflects the **split-apply-combine paradigm** in data analysis: Split the data into partitions, apply some function to the data and then merge the results.

???
comment

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Operations on grouped data:** `group_by()` partitions data based on one or several columns and `summarise()` reduces a group of data into a single row

&lt;img src="https://raw.githubusercontent.com/allisonhorst/stats-illustrations/master/rstats-artwork/group_by_ungroup.png" width="60%" height="60%" style="float:left; padding:10px" /&gt;
&lt;br&gt;
*Note: Instead of using `ungroup()` you may also set the `.groups` argument in `summarise()` equal to "drop".*

*But never forget to ungroup your data, otherwise you may run into errors later on in your analysis!*

???
comments

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Stacked `group_by()`:** If `.add = T` is omitted, the second `group_by()`overrides the first.

```r
penguins %&gt;% 
  group_by(species) %&gt;% 
  group_by(year, .add = T)   # equivalent to group_by(species, year)
```

```
&gt; # A tibble: 344 x 8
&gt; # Groups:   species, year [9]
&gt;    species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
&gt;    &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;
&gt;  1 Adelie  Torge~           39.1          18.7              181        3750 male 
&gt;  2 Adelie  Torge~           39.5          17.4              186        3800 fema~
&gt;  3 Adelie  Torge~           40.3          18                195        3250 fema~
&gt;  4 Adelie  Torge~           NA            NA                 NA          NA &lt;NA&gt; 
&gt;  5 Adelie  Torge~           36.7          19.3              193        3450 fema~
&gt;  6 Adelie  Torge~           39.3          20.6              190        3650 male 
&gt;  7 Adelie  Torge~           38.9          17.8              181        3625 fema~
&gt;  8 Adelie  Torge~           39.2          19.6              195        4675 male 
&gt;  9 Adelie  Torge~           34.1          18.1              193        3475 &lt;NA&gt; 
&gt; 10 Adelie  Torge~           42            20.2              190        4250 &lt;NA&gt; 
&gt; # ... with 334 more rows, and 1 more variable: year &lt;dbl&gt;
```

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Apply multiple summary functions:** Provide a list of `purrr`-style functions to `across()`.

```r
penguins %&gt;% 
  group_by(species) %&gt;%
  summarise(
    across(
      contains("mm"),
      list(avg = ~mean(., na.rm = T), sd = ~sd(., na.rm = T)),
      .names = "{.col}_{.fn}"
    ),
    .groups = "drop"
  )
```

```
&gt; # A tibble: 3 x 7
&gt;   species bill_length_mm_~ bill_length_mm_~ bill_depth_mm_a~ bill_depth_mm_sd
&gt;   &lt;chr&gt;              &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;            &lt;dbl&gt;
&gt; 1 Adelie              38.8             2.66             18.3            1.22 
&gt; 2 Chinst~             48.8             3.34             18.4            1.14 
&gt; 3 Gentoo              47.5             3.08             15.0            0.981
&gt; # ... with 2 more variables: flipper_length_mm_avg &lt;dbl&gt;,
&gt; #   flipper_length_mm_sd &lt;dbl&gt;
```

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Changed behavior of `mutate()`:** Summary functions, e.g., `mean()` or `sd()` now operate on partitions of the data instead of on the whole data frame.

```r
penguins %&gt;% 
  group_by(species) %&gt;% 
  mutate(stand_bm = (body_mass_g - mean(body_mass_g, na.rm = TRUE)) / sd(body_mass_g, na.rm = TRUE))
```

```
&gt; # A tibble: 344 x 9
&gt; # Groups:   species [3]
&gt;    species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
&gt;    &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;
&gt;  1 Adelie  Torge~           39.1          18.7              181        3750 male 
&gt;  2 Adelie  Torge~           39.5          17.4              186        3800 fema~
&gt;  3 Adelie  Torge~           40.3          18                195        3250 fema~
&gt;  4 Adelie  Torge~           NA            NA                 NA          NA &lt;NA&gt; 
&gt;  5 Adelie  Torge~           36.7          19.3              193        3450 fema~
&gt;  6 Adelie  Torge~           39.3          20.6              190        3650 male 
&gt;  7 Adelie  Torge~           38.9          17.8              181        3625 fema~
&gt;  8 Adelie  Torge~           39.2          19.6              195        4675 male 
&gt;  9 Adelie  Torge~           34.1          18.1              193        3475 &lt;NA&gt; 
&gt; 10 Adelie  Torge~           42            20.2              190        4250 &lt;NA&gt; 
&gt; # ... with 334 more rows, and 2 more variables: year &lt;dbl&gt;, stand_bm &lt;dbl&gt;
```

???
- here example of the z-transformation on a group level

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**`group_by()` a transformed column:** Provide a `mutate()`-like expression in your `group_by()` statement.

```r
bm_breaks &lt;- mean(penguins$body_mass_g, na.rm = T) - (-3:3) * sd(penguins$body_mass_g, na.rm = T)

penguins %&gt;% 
  group_by(species, bm_cat = cut(body_mass_g, breaks = bm_breaks)) %&gt;%
  summarise(count = n(), .groups = "drop")
```

```
&gt; # A tibble: 12 x 3
&gt;    species   bm_cat              count
&gt;    &lt;chr&gt;     &lt;fct&gt;               &lt;int&gt;
&gt;  1 Adelie    (2.6e+03,3.4e+03]      39
&gt;  2 Adelie    (3.4e+03,4.2e+03]      87
&gt;  3 Adelie    (4.2e+03,5e+03]        25
&gt;  4 Adelie    &lt;NA&gt;                    1
&gt;  5 Chinstrap (2.6e+03,3.4e+03]      11
&gt;  6 Chinstrap (3.4e+03,4.2e+03]      50
&gt;  7 Chinstrap (4.2e+03,5e+03]         7
&gt;  8 Gentoo    (3.4e+03,4.2e+03]       6
&gt;  9 Gentoo    (4.2e+03,5e+03]        56
&gt; 10 Gentoo    (5e+03,5.81e+03]       52
&gt; 11 Gentoo    (5.81e+03,6.61e+03]     9
&gt; 12 Gentoo    &lt;NA&gt;                    1
```

???
1. compute bins for body mass, the amount of standard deviations from the mean
2. group by data according to these bins (create bins in `group_by()` command)

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Changed behavior of `filter()`:** Filters now operate on partitions of the data instead of on the whole data frame.

```r
penguins %&gt;% 
  group_by(species, island) %&gt;% 
  filter(flipper_length_mm == max(flipper_length_mm, na.rm = T))
```

```
&gt; # A tibble: 5 x 8
&gt; # Groups:   species, island [5]
&gt;   species island bill_length_mm bill_depth_mm flipper_length_~ body_mass_g sex  
&gt;   &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;       &lt;dbl&gt; &lt;chr&gt;
&gt; 1 Adelie  Dream            40.8          18.9              208        4300 male 
&gt; 2 Adelie  Biscoe           41            20                203        4725 male 
&gt; 3 Adelie  Torge~           44.1          18                210        4000 male 
&gt; 4 Gentoo  Biscoe           54.3          15.7              231        5650 male 
&gt; 5 Chinst~ Dream            49            19.6              212        4300 male 
&gt; # ... with 1 more variable: year &lt;dbl&gt;
```

???
- Group by all unique `species`-`island` combinations and filter for the penguins with the maximal flipper length per combination

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**Nesting of grouped data:** Usually, you will find it more intuitive to use `group_by()` followed by `nest()` to produce a nested data frame compared to the example on [slide 33](#tidyr_nest).

```r
penguins %&gt;% 
  group_by(species, year) %&gt;% 
  nest
```

```
&gt; # A tibble: 9 x 3
&gt; # Groups:   species, year [9]
&gt;   species    year data             
&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;list&gt;           
&gt; 1 Adelie     2007 &lt;tibble [50 x 6]&gt;
&gt; 2 Adelie     2008 &lt;tibble [50 x 6]&gt;
&gt; 3 Adelie     2009 &lt;tibble [52 x 6]&gt;
&gt; 4 Gentoo     2007 &lt;tibble [34 x 6]&gt;
&gt; 5 Gentoo     2008 &lt;tibble [46 x 6]&gt;
&gt; 6 Gentoo     2009 &lt;tibble [44 x 6]&gt;
&gt; 7 Chinstrap  2007 &lt;tibble [26 x 6]&gt;
&gt; 8 Chinstrap  2008 &lt;tibble [18 x 6]&gt;
&gt; 9 Chinstrap  2009 &lt;tibble [24 x 6]&gt;
```

.pull-right[.footnote[
*Note: Find more information about* `group_by()` *by running* `vignette("grouping")`.
]]

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**`dplyr::distinct()`:** selects only unique rows

```r
penguins %&gt;% 
  distinct(species, island)
```

**`dplyr::pull()`:** extracts single columns as vectors

```r
penguins %&gt;% 
  pull(year) # equivalent to penguins$year
```

**`dplyr::if_else()`:** applies a vectorized if-else-statement

```r
penguins %&gt;% 
  select(species, island, body_mass_g) %&gt;% 
  mutate(penguin_size = if_else(body_mass_g &lt; 3500, "tiny penguin", "big penguin"))
```

???
- Some more selected `dplyr` functions

---

## 4.5 `dplyr`: A Grammar of Data Manipulation

**`dplyr::lag()` and `dplyr::lead()`:** shifts column values by an offset `n`

```r
penguins %&gt;% 
  select(species, body_mass_g) %&gt;% 
  mutate(
    lagged_bm = lag(body_mass_g, n = 1),
    lead_bm = lead(body_mass_g, n = 2)
  )
```

**`dplyr::left_join()`, `dplyr::right_join()`, `dplyr::inner_join()` and `dplyr::full_join()`:** merge different data frames by matching rows based on keys (similar to joins performed in SQL)

.footnote[
*Note: Find more information about* `dplyr` *by running* `vignette("dplyr")` *and consulting the official [cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/data-transformation.pdf) (note that it may not reflect changes included in* `dplyr v1.0.0`).
]

???
comments

---



---



---

## Thank You!

.pull-left[
.center[**Right now:**]&lt;br&gt;
&lt;img src="https://tenor.com/view/homer-daydreaming-thinking-simpsons-gif-8949118.gif" style="display: block; margin: auto;" /&gt;
]
.pull-right[
.center[**After having mastered the Tidyverse:**]&lt;br&gt;&lt;br&gt;
&lt;img src="https://tenor.com/view/homer-gif-10571731.gif" style="display: block; margin: auto;" /&gt;
]

.footnote[
*Note: Eventually, not everything is great in the `tidyverse`. You should always be aware of its [downsides](https://github.com/matloff/TidyverseSkeptic/blob/master/READMEFull.md) and know when to return to using `base R`.*
]

---

name: references

## References

[1]: **Wickham, H., et al. (2019):** Welcome to the Tidyverse. Journal of Open Source Software, Vol. 4, 2019 No. 43, p. 1686. URL: https://joss.theoj.org/papers/10.21105/joss.01686.pdf.

[2]: **Tidyverse team (2020):** Tidyverse Design Guide. URL: https://design.tidyverse.org/.

[3]: **Wickham, H. (2019):** The Tidy Tools Manifesto. URL: https://cran.r-project.org/web/packages/tidyverse/vignettes/manifesto.html.

[4]: **Wickham, H./Grolemund, G. (2017):** R for Data Science: Visualize, Model, Transform, Tidy, and Import Data. URL: https://r4ds.had.co.nz/tidy-data.html, chapter 12 (Tidy data).

[5]: **Wickham, H. (2014):** Tidy Data. Journal of Statistical Software, Vol. 59, 2014, No. 10, pp. 1-23. URL: https://www.jstatsoft.org/article/view/v059i10.

[6]: **Barter, R. (2019):** Learn to purrr. URL: http://www.rebeccabarter.com/blog/2019-08-19_purrr/#simplest-usage-repeated-looping-with-map.

[7]: **Wickham, H. (2010):** A Layered Grammar of Graphics. Journal of Computational and Graphical Statistics, Vol. 19, 2010, No. 1, pp. 3-28.

---

name: references-2

## References

[8]: **Wilkinson, L. (2005):** The Grammar of Graphics. Springer: New York 2005.

[9]: **Sarkar, D. (2018):** A Comprehensive Guide to the Grammar of Graphics for Effective Visualization of Multidimensional Data. towardsdatascience 2018-09-12. URL: https://towardsdatascience.com/a-comprehensive-guide-to-the-grammar-of-graphics-for-effective-visualization-of-multi-dimensional-1f92b4ed4149).

[10]: **Gahner, E. (2020):** Awesome `ggplot2`. GitHub 2020-09-25. URL: https://github.com/erikgahner/awesome-ggplot2.

---

## Further Resources

Best read for starting in the `tidyverse`:  
**Wickham, H./Grolemund, G. (2017):** R for Data Science: Visualize, Model, Transform, Tidy, and Import Data. URL: https://r4ds.had.co.nz/tidy-data.html.

Additional resource for diving deeper into the world of `ggplot2`:  
**Wickham, H/Navarro, D./Lin Pedersen, T. (2020):** ggplot2: Elegant Graphics for Data Analysis. 3rd. edition, Online Publication 2020. URL: https://ggplot2-book.org/. 

Stay up-to-date with recent developments in the `tidyverse`: https://www.tidyverse.org/blog/

Watch live-coding sessions related to the [TidyTuesday](https://github.com/rfordatascience/tidytuesday) Project, e.g., the episodes by David Robinson: https://www.youtube.com/user/safe4democracy/videos

## Credits

Educational resources are inspired by [workshop materials](https://github.com/rstudio-education/remaster-the-tidyverse) of Garrett Grolemund and [blog posts](https://education.rstudio.com/blog/2020/07/teaching-the-tidyverse-in-2020-part-1-getting-started/) by Mine Ã‡etinkaya-Rundel of the RStudio Education team.

`tidyverse` [artworks and illustration](https://github.com/allisonhorst/stats-illustrations) are provided by Allison Horst.

???
convert online presentation to pdf:

docker run --rm -t -v %cd%/desktop/l09_desktop/workshops/02_tidyverse/slides:/slides astefanutti/decktape https://simonschoe.github.io/Introduction-to-the-Tidyverse/#1 index.pdf
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
